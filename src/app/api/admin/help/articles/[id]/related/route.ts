import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '@/lib/auth/config'
import { prisma } from '@/lib/prisma'
import { normalizeUserId } from '@/lib/auth/demo-user'

interface RouteParams {
  params: {
    id: string
  }
}

// GET /api/admin/help/articles/[id]/related - Get related articles for an article
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    // Check authentication and admin permissions
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const userId = normalizeUserId(session.user.id)

    // Verify user has admin permissions
    const userWorkspaces = await prisma.userWorkspace.findMany({
      where: {
        userId,
        role: { in: ['OWNER', 'ADMIN'] }
      }
    })

    if (userWorkspaces.length === 0) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id: articleId } = params

    // Verify article exists
    const article = await prisma.helpArticle.findUnique({
      where: { id: articleId },
      include: {
        category: true
      }
    })

    if (!article) {
      return NextResponse.json({ error: 'Article not found' }, { status: 404 })
    }

    // Get explicitly related articles (both directions)
    const explicitRelated = await prisma.helpArticleRelation.findMany({
      where: {
        OR: [
          { fromArticleId: articleId },
          { toArticleId: articleId }
        ]
      },
      include: {
        fromArticle: {
          select: {
            id: true,
            title: true,
            slug: true,
            status: true,
            excerpt: true,
            category: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        toArticle: {
          select: {
            id: true,
            title: true,
            slug: true,
            status: true,
            excerpt: true,
            category: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    })

    // Format explicit relationships
    const relatedArticles = explicitRelated.map(relation => {
      const isFromRelation = relation.fromArticleId === articleId
      const relatedArticle = isFromRelation ? relation.toArticle : relation.fromArticle

      return {
        id: relation.id,
        article: relatedArticle,
        relationType: relation.relationType,
        isAutoGenerated: relation.isAutoGenerated,
        strength: relation.strength,
        createdAt: relation.createdAt
      }
    })

    // Get suggested articles based on various criteria
    const suggestions = await generateSuggestions(articleId, article)

    return NextResponse.json({
      article: {
        id: article.id,
        title: article.title,
        category: article.category
      },
      related: relatedArticles,
      suggestions
    })
  } catch (error) {
    console.error('Failed to fetch related articles:', error)
    return NextResponse.json(
      { error: 'Failed to fetch related articles' },
      { status: 500 }
    )
  }
}

// POST /api/admin/help/articles/[id]/related - Add related article
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    // Check authentication and admin permissions
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const userId = normalizeUserId(session.user.id)

    // Verify user has admin permissions
    const userWorkspaces = await prisma.userWorkspace.findMany({
      where: {
        userId,
        role: { in: ['OWNER', 'ADMIN'] }
      }
    })

    if (userWorkspaces.length === 0) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id: fromArticleId } = params
    const { toArticleId, relationType = 'related', bidirectional = true } = await request.json()

    // Validate required fields
    if (!toArticleId) {
      return NextResponse.json(
        { error: 'toArticleId is required' },
        { status: 400 }
      )
    }

    if (fromArticleId === toArticleId) {
      return NextResponse.json(
        { error: 'Cannot relate article to itself' },
        { status: 400 }
      )
    }

    // Verify both articles exist
    const [fromArticle, toArticle] = await Promise.all([
      prisma.helpArticle.findUnique({ where: { id: fromArticleId } }),
      prisma.helpArticle.findUnique({ where: { id: toArticleId } })
    ])

    if (!fromArticle || !toArticle) {
      return NextResponse.json(
        { error: 'One or both articles not found' },
        { status: 400 }
      )
    }

    // Check if relationship already exists
    const existingRelation = await prisma.helpArticleRelation.findFirst({
      where: {
        OR: [
          { fromArticleId, toArticleId },
          { fromArticleId: toArticleId, toArticleId: fromArticleId }
        ]
      }
    })

    if (existingRelation) {
      return NextResponse.json(
        { error: 'Relationship already exists' },
        { status: 400 }
      )
    }

    // Calculate relationship strength based on various factors
    const strength = await calculateRelationshipStrength(fromArticle, toArticle)

    // Create the relationship(s)
    const relations = []

    // Create primary relationship
    const primaryRelation = await prisma.helpArticleRelation.create({
      data: {
        fromArticleId,
        toArticleId,
        relationType,
        strength,
        isAutoGenerated: false
      },
      include: {
        toArticle: {
          select: {
            id: true,
            title: true,
            slug: true,
            status: true,
            excerpt: true,
            category: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    })

    relations.push(primaryRelation)

    // Create bidirectional relationship if requested
    if (bidirectional) {
      const reverseRelation = await prisma.helpArticleRelation.create({
        data: {
          fromArticleId: toArticleId,
          toArticleId: fromArticleId,
          relationType,
          strength,
          isAutoGenerated: false
        }
      })

      relations.push(reverseRelation)
    }

    return NextResponse.json({
      message: 'Related article added successfully',
      relations
    }, { status: 201 })
  } catch (error) {
    console.error('Failed to add related article:', error)
    return NextResponse.json(
      { error: 'Failed to add related article' },
      { status: 500 }
    )
  }
}

// Helper function to generate article suggestions
async function generateSuggestions(articleId: string, article: any) {
  const suggestions = []

  // 1. Articles in the same category
  const sameCategoryArticles = await prisma.helpArticle.findMany({
    where: {
      categoryId: article.categoryId,
      id: { not: articleId },
      status: 'published'
    },
    select: {
      id: true,
      title: true,
      slug: true,
      excerpt: true,
      tags: true,
      category: {
        select: {
          id: true,
          name: true
        }
      }
    },
    take: 5
  })

  suggestions.push(...sameCategoryArticles.map(a => ({
    ...a,
    suggestionType: 'same_category',
    reason: `Same category: ${article.category.name}`,
    score: 0.7
  })))

  // 2. Articles with overlapping tags
  if (article.tags && article.tags.length > 0) {
    const taggedArticles = await prisma.helpArticle.findMany({
      where: {
        id: { not: articleId },
        status: 'published',
        tags: {
          hasSome: article.tags
        }
      },
      select: {
        id: true,
        title: true,
        slug: true,
        excerpt: true,
        tags: true,
        category: {
          select: {
            id: true,
            name: true
          }
        }
      },
      take: 5
    })

    suggestions.push(...taggedArticles.map(a => {
      const commonTags = a.tags.filter(tag => article.tags.includes(tag))
      return {
        ...a,
        suggestionType: 'common_tags',
        reason: `Common tags: ${commonTags.join(', ')}`,
        score: 0.6 + (commonTags.length * 0.1)
      }
    }))
  }

  // 3. Recently popular articles (based on analytics if available)
  const popularArticles = await prisma.helpArticle.findMany({
    where: {
      id: { not: articleId },
      status: 'published'
    },
    select: {
      id: true,
      title: true,
      slug: true,
      excerpt: true,
      tags: true,
      category: {
        select: {
          id: true,
          name: true
        }
      },
      _count: {
        select: {
          analytics: true
        }
      }
    },
    orderBy: {
      analytics: {
        _count: 'desc'
      }
    },
    take: 3
  })

  suggestions.push(...popularArticles.map(a => ({
    ...a,
    suggestionType: 'popular',
    reason: 'Popular article',
    score: 0.5
  })))

  // 4. Text similarity suggestions (simplified - could use more advanced NLP)
  const allArticles = await prisma.helpArticle.findMany({
    where: {
      id: { not: articleId },
      status: 'published'
    },
    select: {
      id: true,
      title: true,
      slug: true,
      excerpt: true,
      content: true,
      tags: true,
      category: {
        select: {
          id: true,
          name: true
        }
      }
    }
  })

  const textSimilarityArticles = allArticles
    .map(a => ({
      ...a,
      similarity: calculateTextSimilarity(article.content, a.content)
    }))
    .filter(a => a.similarity > 0.2)
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, 3)
    .map(a => ({
      ...a,
      suggestionType: 'text_similarity',
      reason: `Similar content (${Math.round(a.similarity * 100)}% match)`,
      score: a.similarity
    }))

  suggestions.push(...textSimilarityArticles)

  // Remove duplicates and sort by score
  const uniqueSuggestions = suggestions
    .filter((suggestion, index, self) =>
      self.findIndex(s => s.id === suggestion.id) === index
    )
    .sort((a, b) => b.score - a.score)
    .slice(0, 10)

  return uniqueSuggestions
}

// Helper function to calculate relationship strength
async function calculateRelationshipStrength(article1: any, article2: any): Promise<number> {
  let strength = 0

  // Same category: +0.3
  if (article1.categoryId === article2.categoryId) {
    strength += 0.3
  }

  // Common tags: +0.1 per tag
  if (article1.tags && article2.tags) {
    const commonTags = article1.tags.filter((tag: string) => article2.tags.includes(tag))
    strength += commonTags.length * 0.1
  }

  // Content similarity: up to +0.4
  const contentSimilarity = calculateTextSimilarity(article1.content, article2.content)
  strength += contentSimilarity * 0.4

  // Title similarity: up to +0.2
  const titleSimilarity = calculateTextSimilarity(article1.title, article2.title)
  strength += titleSimilarity * 0.2

  // Ensure strength is between 0 and 1
  return Math.min(Math.max(strength, 0), 1)
}

// Simple text similarity calculation (could be improved with more advanced algorithms)
function calculateTextSimilarity(text1: string, text2: string): number {
  // Convert to lowercase and split into words
  const words1 = text1.toLowerCase().match(/\b\w+\b/g) || []
  const words2 = text2.toLowerCase().match(/\b\w+\b/g) || []

  // Remove common stop words
  const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'])

  const filteredWords1 = words1.filter(word => !stopWords.has(word) && word.length > 2)
  const filteredWords2 = words2.filter(word => !stopWords.has(word) && word.length > 2)

  if (filteredWords1.length === 0 || filteredWords2.length === 0) {
    return 0
  }

  // Calculate Jaccard similarity
  const set1 = new Set(filteredWords1)
  const set2 = new Set(filteredWords2)

  const intersection = new Set([...set1].filter(word => set2.has(word)))
  const union = new Set([...set1, ...set2])

  return intersection.size / union.size
}