import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { normalizeUserId } from '@/lib/auth/utils'
import * as fs from 'fs'
import * as path from 'path'

interface APIRoute {
  path: string
  method: string
  description?: string
  parameters?: any[]
  responses?: any
  tags?: string[]
}

interface APIDocumentation {
  title: string
  description: string
  version: string
  baseUrl: string
  routes: APIRoute[]
  schemas?: any
}

// POST /api/documentation/api-docs/generate - Generate API documentation from code
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const normalizedUserId = normalizeUserId(session.user.id)
    const body = await request.json()
    const {
      scanPaths = ['src/app/api'],
      outputFormat = 'openapi',
      includeSchemas = true,
      includeExamples = true,
      title = 'API Documentation',
      description = 'Auto-generated API documentation',
      version = '1.0.0',
      baseUrl = '/api'
    } = body

    // Scan API routes
    const routes = await scanAPIRoutes(scanPaths)

    // Generate documentation based on format
    let documentation: any

    switch (outputFormat) {
      case 'openapi':
        documentation = generateOpenAPIDoc({
          title,
          description,
          version,
          baseUrl,
          routes,
          includeSchemas,
          includeExamples
        })
        break
      case 'markdown':
        documentation = generateMarkdownDoc({
          title,
          description,
          version,
          baseUrl,
          routes
        })
        break
      case 'json':
      default:
        documentation = {
          title,
          description,
          version,
          baseUrl,
          routes,
          generatedAt: new Date().toISOString()
        }
        break
    }

    // Create or update documentation page
    const slug = 'api-documentation'
    const sectionId = await getOrCreateAPISection()

    const existingPage = await prisma.documentationPage.findUnique({
      where: { slug }
    })

    let pageData: any = {
      title: 'API Documentation',
      slug,
      content: typeof documentation === 'string' ? documentation : JSON.stringify(documentation, null, 2),
      excerpt: 'Auto-generated API documentation for all endpoints',
      sectionId,
      tags: ['api', 'auto-generated', outputFormat],
      status: 'PUBLISHED',
      visibility: 'INTERNAL',
      authorId: normalizedUserId,
      metadata: {
        autoGenerated: true,
        generatedAt: new Date().toISOString(),
        outputFormat,
        routeCount: routes.length
      }
    }

    let page: any

    if (existingPage) {
      page = await prisma.documentationPage.update({
        where: { slug },
        data: pageData
      })
    } else {
      page = await prisma.documentationPage.create({
        data: pageData
      })
    }

    return NextResponse.json({
      success: true,
      page,
      documentation,
      stats: {
        routesFound: routes.length,
        format: outputFormat,
        generatedAt: new Date().toISOString()
      }
    })
  } catch (error) {
    console.error('Failed to generate API documentation:', error)
    return NextResponse.json(
      { error: 'Failed to generate API documentation' },
      { status: 500 }
    )
  }
}

async function scanAPIRoutes(scanPaths: string[]): Promise<APIRoute[]> {
  const routes: APIRoute[] = []

  // Mock API route scanning - in a real implementation, this would:
  // 1. Use filesystem to read all route.ts files
  // 2. Parse TypeScript/JavaScript to extract route handlers
  // 3. Extract JSDoc comments for descriptions
  // 4. Analyze request/response types

  // For now, return mock data representing common SociallyHub API routes
  const mockRoutes: APIRoute[] = [
    {
      path: '/api/auth/signup',
      method: 'POST',
      description: 'Create a new user account',
      parameters: [
        { name: 'email', type: 'string', required: true, description: 'User email address' },
        { name: 'password', type: 'string', required: true, description: 'User password' },
        { name: 'name', type: 'string', required: true, description: 'User full name' }
      ],
      responses: {
        '201': { description: 'User created successfully', schema: { type: 'object' } },
        '400': { description: 'Invalid input data' },
        '409': { description: 'Email already exists' }
      },
      tags: ['Authentication']
    },
    {
      path: '/api/documentation/pages',
      method: 'GET',
      description: 'Get documentation pages',
      parameters: [
        { name: 'limit', type: 'number', required: false, description: 'Number of pages to return' },
        { name: 'offset', type: 'number', required: false, description: 'Number of pages to skip' },
        { name: 'search', type: 'string', required: false, description: 'Search query' }
      ],
      responses: {
        '200': { description: 'List of documentation pages', schema: { type: 'array' } },
        '500': { description: 'Server error' }
      },
      tags: ['Documentation']
    },
    {
      path: '/api/documentation/pages',
      method: 'POST',
      description: 'Create a new documentation page',
      parameters: [
        { name: 'title', type: 'string', required: true, description: 'Page title' },
        { name: 'content', type: 'string', required: true, description: 'Page content' },
        { name: 'sectionId', type: 'string', required: true, description: 'Section ID' }
      ],
      responses: {
        '201': { description: 'Page created successfully' },
        '400': { description: 'Invalid input data' },
        '404': { description: 'Section not found' }
      },
      tags: ['Documentation']
    },
    {
      path: '/api/documentation/manage',
      method: 'GET',
      description: 'Get documentation pages for management (including drafts)',
      parameters: [
        { name: 'status', type: 'string', required: false, description: 'Filter by status' },
        { name: 'sectionSlug', type: 'string', required: false, description: 'Filter by section' }
      ],
      responses: {
        '200': { description: 'List of documentation pages with management data' },
        '401': { description: 'Unauthorized' }
      },
      tags: ['Documentation', 'Management']
    },
    {
      path: '/api/documentation/analytics',
      method: 'GET',
      description: 'Get documentation analytics data',
      parameters: [
        { name: 'period', type: 'string', required: false, description: 'Time period (7d, 30d, 90d, 1y)' },
        { name: 'pageId', type: 'string', required: false, description: 'Specific page ID' }
      ],
      responses: {
        '200': { description: 'Analytics data including trends and performance metrics' },
        '401': { description: 'Unauthorized' }
      },
      tags: ['Documentation', 'Analytics']
    },
    {
      path: '/api/campaigns',
      method: 'GET',
      description: 'Get marketing campaigns',
      parameters: [
        { name: 'status', type: 'string', required: false, description: 'Filter by campaign status' },
        { name: 'limit', type: 'number', required: false, description: 'Number of campaigns to return' }
      ],
      responses: {
        '200': { description: 'List of campaigns' },
        '401': { description: 'Unauthorized' }
      },
      tags: ['Campaigns']
    },
    {
      path: '/api/campaigns',
      method: 'POST',
      description: 'Create a new marketing campaign',
      parameters: [
        { name: 'name', type: 'string', required: true, description: 'Campaign name' },
        { name: 'objective', type: 'string', required: true, description: 'Campaign objective' },
        { name: 'budget', type: 'number', required: false, description: 'Campaign budget' }
      ],
      responses: {
        '201': { description: 'Campaign created successfully' },
        '400': { description: 'Invalid input data' }
      },
      tags: ['Campaigns']
    },
    {
      path: '/api/clients',
      method: 'GET',
      description: 'Get client list',
      parameters: [
        { name: 'search', type: 'string', required: false, description: 'Search clients by name or email' },
        { name: 'onboardingStatus', type: 'string', required: false, description: 'Filter by onboarding status' }
      ],
      responses: {
        '200': { description: 'List of clients' },
        '401': { description: 'Unauthorized' }
      },
      tags: ['Clients']
    },
    {
      path: '/api/analytics/dashboard',
      method: 'GET',
      description: 'Get dashboard analytics data',
      parameters: [
        { name: 'range', type: 'string', required: false, description: 'Date range (7d, 30d, 90d)' }
      ],
      responses: {
        '200': { description: 'Dashboard analytics including metrics and trends' },
        '401': { description: 'Unauthorized' }
      },
      tags: ['Analytics']
    }
  ]

  return mockRoutes
}

async function getOrCreateAPISection(): Promise<string> {
  const slug = 'api-reference'

  let section = await prisma.documentationSection.findUnique({
    where: { slug }
  })

  if (!section) {
    section = await prisma.documentationSection.create({
      data: {
        title: 'API Reference',
        slug,
        description: 'Complete API documentation and reference',
        icon: 'Code',
        sortOrder: 999,
        isActive: true
      }
    })
  }

  return section.id
}

function generateOpenAPIDoc(config: any): any {
  const { title, description, version, baseUrl, routes, includeSchemas, includeExamples } = config

  const openapi = {
    openapi: '3.0.0',
    info: {
      title,
      description,
      version
    },
    servers: [
      { url: baseUrl, description: 'API Server' }
    ],
    paths: {} as any,
    components: {
      schemas: includeSchemas ? {
        Error: {
          type: 'object',
          properties: {
            error: { type: 'string', description: 'Error message' }
          }
        },
        Success: {
          type: 'object',
          properties: {
            success: { type: 'boolean', description: 'Operation success status' }
          }
        }
      } : undefined
    },
    tags: Array.from(new Set(routes.flatMap((r: APIRoute) => r.tags || []))).map(tag => ({
      name: tag,
      description: `${tag} related endpoints`
    }))
  }

  // Group routes by path
  routes.forEach((route: APIRoute) => {
    if (!openapi.paths[route.path]) {
      openapi.paths[route.path] = {}
    }

    const operation: any = {
      summary: route.description,
      tags: route.tags,
      parameters: route.parameters?.map(param => ({
        name: param.name,
        in: param.required ? 'body' : 'query',
        required: param.required,
        description: param.description,
        schema: { type: param.type }
      })),
      responses: route.responses || {
        '200': { description: 'Successful operation' },
        '400': { description: 'Bad request' },
        '500': { description: 'Internal server error' }
      }
    }

    if (includeExamples && route.method === 'POST') {
      operation.requestBody = {
        required: true,
        content: {
          'application/json': {
            schema: { type: 'object' },
            example: route.parameters?.reduce((acc, param) => {
              acc[param.name] = param.type === 'string' ? 'example value' : param.type === 'number' ? 123 : true
              return acc
            }, {} as any)
          }
        }
      }
    }

    openapi.paths[route.path][route.method.toLowerCase()] = operation
  })

  return openapi
}

function generateMarkdownDoc(config: any): string {
  const { title, description, version, baseUrl, routes } = config

  let markdown = `# ${title}\n\n`
  markdown += `${description}\n\n`
  markdown += `**Version:** ${version}  \n`
  markdown += `**Base URL:** ${baseUrl}\n\n`

  // Group routes by tag
  const routesByTag = routes.reduce((acc: any, route: APIRoute) => {
    const tag = route.tags?.[0] || 'General'
    if (!acc[tag]) acc[tag] = []
    acc[tag].push(route)
    return acc
  }, {})

  Object.entries(routesByTag).forEach(([tag, tagRoutes]: [string, any]) => {
    markdown += `## ${tag}\n\n`

    tagRoutes.forEach((route: APIRoute) => {
      markdown += `### ${route.method.toUpperCase()} ${route.path}\n\n`

      if (route.description) {
        markdown += `${route.description}\n\n`
      }

      if (route.parameters?.length) {
        markdown += `#### Parameters\n\n`
        markdown += `| Name | Type | Required | Description |\n`
        markdown += `|------|------|----------|-------------|\n`
        route.parameters.forEach(param => {
          markdown += `| ${param.name} | ${param.type} | ${param.required ? 'Yes' : 'No'} | ${param.description || ''} |\n`
        })
        markdown += `\n`
      }

      if (route.responses) {
        markdown += `#### Responses\n\n`
        Object.entries(route.responses).forEach(([code, response]: [string, any]) => {
          markdown += `- **${code}**: ${response.description || 'No description'}\n`
        })
        markdown += `\n`
      }

      markdown += `---\n\n`
    })
  })

  return markdown
}